import React, { createContext, useContext, useState, useEffect, useMemo } from 'react';
import toast from 'react-hot-toast';

const WhiteLabelContext = createContext();

export const useWhiteLabel = () => {
  const context = useContext(WhiteLabelContext);
  if (!context) {
    throw new Error('useWhiteLabel must be used within WhiteLabelProvider');
  }
  return context;
};

const DEFAULT_SETTINGS = {
  enabled: false,
  customDomain: '',
  companyName: 'AdCopySurge',
  customLogo: null,
  primaryColor: '#7C3AED',
  secondaryColor: '#A855F7',
  accentColor: '#10b981',
  hideOriginalBranding: false,
  removePoweredBy: false,
  customLoginPage: false,
  customEmailTemplate: false,
  sslEnabled: true,
  subdomainPrefix: 'app',
  favicon: null,
  reportHeaderLogo: null,
  reportFooterText: 'Generated by Your Agency Name',
  customReportTemplate: false,
  watermarkRemoval: false,
  customSupportEmail: '',
  customTermsUrl: '',
  customPrivacyUrl: '',
  // Preview mode
  previewMode: false,
  // Setup wizard progress
  setupStep: 0,
  setupCompleted: false
};

export const WhiteLabelProvider = ({ children }) => {
  const [settings, setSettings] = useState(() => {
    // Load from localStorage on initialization
    try {
      const saved = localStorage.getItem('whiteLabel-settings');
      return saved ? { ...DEFAULT_SETTINGS, ...JSON.parse(saved) } : DEFAULT_SETTINGS;
    } catch (error) {
      console.error('Failed to load white-label settings:', error);
      return DEFAULT_SETTINGS;
    }
  });

  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  // Persist settings to localStorage whenever they change
  useEffect(() => {
    try {
      localStorage.setItem('whiteLabel-settings', JSON.stringify(settings));
      console.log('ðŸŽ¨ White-label settings saved to localStorage');
    } catch (error) {
      console.error('Failed to save white-label settings:', error);
    }
  }, [settings]);

  // Update a single setting
  const updateSetting = (key, value) => {
    setSettings(prev => ({
      ...prev,
      [key]: value
    }));
  };

  // Update multiple settings at once
  const updateSettings = (newSettings) => {
    setSettings(prev => ({
      ...prev,
      ...newSettings
    }));
  };

  // Reset to defaults
  const resetSettings = () => {
    setSettings(DEFAULT_SETTINGS);
    toast.success('White-label settings reset to defaults');
  };

  // Toggle preview mode
  const togglePreviewMode = () => {
    updateSetting('previewMode', !settings.previewMode);
  };

  // File upload handler for logos and favicons
  const uploadFile = async (file, type = 'logo') => {
    if (!file) return null;

    // Validate file
    const maxSize = 5 * 1024 * 1024; // 5MB
    if (file.size > maxSize) {
      throw new Error('File must be smaller than 5MB');
    }

    const allowedTypes = {
      logo: ['image/png', 'image/jpeg', 'image/jpg', 'image/svg+xml', 'image/webp'],
      favicon: ['image/x-icon', 'image/png', 'image/svg+xml'],
      reportLogo: ['image/png', 'image/jpeg', 'image/jpg', 'image/svg+xml', 'image/webp']
    };

    // If no specific type is provided, use general image validation
    const validTypes = allowedTypes[type] || ['image/png', 'image/jpeg', 'image/jpg', 'image/svg+xml', 'image/webp'];
    
    if (!validTypes.includes(file.type)) {
      throw new Error(`Invalid file type. Please use: ${validTypes.map(t => t.split('/')[1].toUpperCase()).join(', ')}`);
    }

    try {
      setIsLoading(true);
      
      // Convert to base64 for now (in production, upload to cloud storage)
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsDataURL(file);
      });
    } finally {
      setIsLoading(false);
    }
  };

  // Handle logo upload
  const handleLogoUpload = async (file) => {
    try {
      const logoData = await uploadFile(file, 'logo');
      updateSetting('customLogo', logoData);
      toast.success('Logo uploaded successfully!');
    } catch (error) {
      console.error('Logo upload failed:', error);
      toast.error(error.message);
      throw error;
    }
  };

  // Handle favicon upload
  const handleFaviconUpload = async (file) => {
    try {
      const faviconData = await uploadFile(file, 'favicon');
      updateSetting('favicon', faviconData);
      toast.success('Favicon uploaded successfully!');
    } catch (error) {
      console.error('Favicon upload failed:', error);
      toast.error(error.message);
      throw error;
    }
  };

  // Handle report logo upload
  const handleReportLogoUpload = async (file) => {
    try {
      const logoData = await uploadFile(file, 'reportLogo');
      updateSetting('reportHeaderLogo', logoData);
      toast.success('Report logo uploaded successfully!');
    } catch (error) {
      console.error('Report logo upload failed:', error);
      toast.error(error.message);
      throw error;
    }
  };

  // Validate domain format
  const validateDomain = (domain) => {
    const domainRegex = /^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]*\.([a-zA-Z]{2,})$/;
    return domainRegex.test(domain);
  };

  // Setup wizard navigation
  const nextStep = () => {
    updateSetting('setupStep', Math.min(settings.setupStep + 1, 4));
  };

  const prevStep = () => {
    updateSetting('setupStep', Math.max(settings.setupStep - 1, 0));
  };

  const completeSetup = () => {
    updateSettings({
      setupCompleted: true,
      setupStep: 4
    });
    toast.success('White-label setup completed!');
  };

  // Memoize effective branding values to prevent infinite re-renders
  const effectiveBranding = useMemo(() => ({
    companyName: settings.companyName || 'AdCopySurge',
    logo: settings.customLogo || null,
    primaryColor: settings.primaryColor || '#7C3AED',
    secondaryColor: settings.secondaryColor || '#A855F7',
    customDomain: settings.customDomain || '',
    customSupportEmail: settings.customSupportEmail || '',
    showPoweredBy: !settings.removePoweredBy,
    // Always return these values regardless of enabled state
    enabled: settings.enabled || false,
    setupCompleted: settings.setupCompleted || false
  }), [settings]);

  // Get effective branding values (kept for backward compatibility)
  const getEffectiveBranding = () => effectiveBranding;

  // Save settings (for wizard completion)
  const saveSettings = async () => {
    try {
      setIsLoading(true);
      
      // In production, this would save to backend API
      // For now, we just ensure localStorage is updated
      localStorage.setItem('whiteLabel-settings', JSON.stringify(settings));
      
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 500));
      
      console.log('âœ… White-label settings saved successfully');
      return { success: true };
    } catch (error) {
      console.error('Failed to save white-label settings:', error);
      setError(error.message);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Enable/disable preview mode
  const enablePreview = () => {
    updateSetting('previewMode', true);
    console.log('ðŸŽ¨ Preview mode enabled');
  };

  const disablePreview = () => {
    updateSetting('previewMode', false);
    console.log('ðŸŽ¨ Preview mode disabled');
  };


  // Check if minimum setup is complete
  const isMinimumSetupComplete = () => {
    return settings.enabled && 
           settings.companyName && 
           settings.primaryColor;
  };

  const value = {
    // Settings state
    settings,
    isLoading,
    error,
    
    // Settings actions
    updateSetting,
    updateSettings,
    resetSettings,
    saveSettings,
    
    // File uploads
    handleLogoUpload,
    handleFaviconUpload,
    handleReportLogoUpload,
    uploadFile,
    
    // Preview mode
    togglePreviewMode,
    enablePreview,
    disablePreview,
    
    // Setup wizard
    nextStep,
    prevStep,
    completeSetup,
    
    // Validation
    validateDomain,
    isMinimumSetupComplete,
    
    // Computed values
    effectiveBranding,
    getEffectiveBranding,
    
    // Constants
    DEFAULT_SETTINGS
  };

  return (
    <WhiteLabelContext.Provider value={value}>
      {children}
    </WhiteLabelContext.Provider>
  );
};