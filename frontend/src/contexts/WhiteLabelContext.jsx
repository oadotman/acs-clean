import React, { createContext, useContext, useState, useEffect, useMemo } from 'react';
import toast from 'react-hot-toast';
import * as whitelabelAPI from '../services/whitelabelService';

const WhiteLabelContext = createContext();

export const useWhiteLabel = () => {
  const context = useContext(WhiteLabelContext);
  if (!context) {
    throw new Error('useWhiteLabel must be used within WhiteLabelProvider');
  }
  return context;
};

const DEFAULT_SETTINGS = {
  enabled: false,
  customDomain: '',
  companyName: 'AdCopySurge',
  customLogo: null,
  primaryColor: '#7C3AED',
  secondaryColor: '#A855F7',
  accentColor: '#10b981',
  hideOriginalBranding: false,
  removePoweredBy: false,
  customLoginPage: false,
  customEmailTemplate: false,
  sslEnabled: true,
  subdomainPrefix: 'app',
  favicon: null,
  reportHeaderLogo: null,
  reportFooterText: 'Generated by Your Agency Name',
  customReportTemplate: false,
  watermarkRemoval: false,
  customSupportEmail: '',
  customTermsUrl: '',
  customPrivacyUrl: '',
  // Preview mode
  previewMode: false,
  // Setup wizard progress
  setupStep: 0,
  setupCompleted: false
};

export const WhiteLabelProvider = ({ children }) => {
  const [settings, setSettings] = useState(() => {
    // Load from localStorage on initialization (fallback)
    try {
      const saved = localStorage.getItem('whiteLabel-settings');
      return saved ? { ...DEFAULT_SETTINGS, ...JSON.parse(saved) } : DEFAULT_SETTINGS;
    } catch (error) {
      console.error('Failed to load white-label settings:', error);
      return DEFAULT_SETTINGS;
    }
  });

  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [agencyId, setAgencyId] = useState(() => {
    // Get agency ID from localStorage
    return localStorage.getItem('whiteLabel-agencyId') || null;
  });

  // Persist settings to localStorage whenever they change
  useEffect(() => {
    try {
      localStorage.setItem('whiteLabel-settings', JSON.stringify(settings));
      console.log('ðŸŽ¨ White-label settings saved to localStorage');
    } catch (error) {
      console.error('Failed to save white-label settings:', error);
    }
  }, [settings]);

  // Update a single setting
  const updateSetting = (key, value) => {
    setSettings(prev => ({
      ...prev,
      [key]: value
    }));
  };

  // Update multiple settings at once
  const updateSettings = (newSettings) => {
    setSettings(prev => ({
      ...prev,
      ...newSettings
    }));
  };

  // Reset to defaults
  const resetSettings = () => {
    setSettings(DEFAULT_SETTINGS);
    toast.success('White-label settings reset to defaults');
  };

  // Toggle preview mode
  const togglePreviewMode = () => {
    updateSetting('previewMode', !settings.previewMode);
  };

  // File upload handler for logos and favicons
  const uploadFile = async (file, type = 'logo') => {
    if (!file) return null;

    // Validate file
    const maxSize = 5 * 1024 * 1024; // 5MB
    if (file.size > maxSize) {
      throw new Error('File must be smaller than 5MB');
    }

    const allowedTypes = {
      logo: ['image/png', 'image/jpeg', 'image/jpg', 'image/svg+xml', 'image/webp'],
      favicon: ['image/x-icon', 'image/png', 'image/svg+xml'],
      reportLogo: ['image/png', 'image/jpeg', 'image/jpg', 'image/svg+xml', 'image/webp']
    };

    // If no specific type is provided, use general image validation
    const validTypes = allowedTypes[type] || ['image/png', 'image/jpeg', 'image/jpg', 'image/svg+xml', 'image/webp'];
    
    if (!validTypes.includes(file.type)) {
      throw new Error(`Invalid file type. Please use: ${validTypes.map(t => t.split('/')[1].toUpperCase()).join(', ')}`);
    }

    try {
      setIsLoading(true);
      
      // Convert to base64 for now (in production, upload to cloud storage)
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsDataURL(file);
      });
    } finally {
      setIsLoading(false);
    }
  };

  // Handle logo upload (with backend API)
  const handleLogoUpload = async (file) => {
    try {
      setIsLoading(true);

      // If no agency exists, create one first
      if (!agencyId) {
        const defaultName = settings.companyName || 'My Agency';
        const agency = await whitelabelAPI.createAgency(defaultName);
        setAgencyId(agency.id);
        localStorage.setItem('whiteLabel-agencyId', agency.id);
      }

      // Upload logo to backend (Supabase Storage)
      const result = await whitelabelAPI.uploadLogo(agencyId, file);

      if (result.success) {
        updateSetting('customLogo', result.url);
        toast.success('Logo uploaded successfully!');
        return result.url;
      } else {
        throw new Error('Upload failed');
      }
    } catch (error) {
      console.error('Logo upload failed:', error);
      toast.error(error.message || 'Failed to upload logo');
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Handle favicon upload
  const handleFaviconUpload = async (file) => {
    try {
      const faviconData = await uploadFile(file, 'favicon');
      updateSetting('favicon', faviconData);
      toast.success('Favicon uploaded successfully!');
    } catch (error) {
      console.error('Favicon upload failed:', error);
      toast.error(error.message);
      throw error;
    }
  };

  // Handle report logo upload
  const handleReportLogoUpload = async (file) => {
    try {
      const logoData = await uploadFile(file, 'reportLogo');
      updateSetting('reportHeaderLogo', logoData);
      toast.success('Report logo uploaded successfully!');
    } catch (error) {
      console.error('Report logo upload failed:', error);
      toast.error(error.message);
      throw error;
    }
  };

  // Validate domain format
  const validateDomain = (domain) => {
    const domainRegex = /^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]*\.([a-zA-Z]{2,})$/;
    return domainRegex.test(domain);
  };

  // Setup wizard navigation
  const nextStep = () => {
    updateSetting('setupStep', Math.min(settings.setupStep + 1, 4));
  };

  const prevStep = () => {
    updateSetting('setupStep', Math.max(settings.setupStep - 1, 0));
  };

  const completeSetup = () => {
    updateSettings({
      setupCompleted: true,
      setupStep: 4
    });
    toast.success('White-label setup completed!');
  };

  // Memoize effective branding values to prevent infinite re-renders
  const effectiveBranding = useMemo(() => ({
    companyName: settings.companyName || 'AdCopySurge',
    logo: settings.customLogo || null,
    primaryColor: settings.primaryColor || '#7C3AED',
    secondaryColor: settings.secondaryColor || '#A855F7',
    customDomain: settings.customDomain || '',
    customSupportEmail: settings.customSupportEmail || '',
    showPoweredBy: !settings.removePoweredBy,
    // Always return these values regardless of enabled state
    enabled: settings.enabled || false,
    setupCompleted: settings.setupCompleted || false
  }), [settings]);

  // Get effective branding values (kept for backward compatibility)
  const getEffectiveBranding = () => effectiveBranding;

  // Save settings (with backend API)
  const saveSettings = async () => {
    try {
      setIsLoading(true);

      // If no agency exists, create one first
      if (!agencyId) {
        const defaultName = settings.companyName || 'My Agency';
        const agency = await whitelabelAPI.createAgency(defaultName);
        setAgencyId(agency.id);
        localStorage.setItem('whiteLabel-agencyId', agency.id);
      }

      // Save settings to backend
      await whitelabelAPI.updateWhitelabelSettings(agencyId, settings);

      // Also save to localStorage as backup
      localStorage.setItem('whiteLabel-settings', JSON.stringify(settings));

      console.log('âœ… White-label settings saved successfully');
      toast.success('Settings saved successfully!');
      return { success: true };
    } catch (error) {
      console.error('Failed to save white-label settings:', error);
      setError(error.message);
      toast.error('Failed to save settings');
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Enable/disable preview mode
  const enablePreview = () => {
    updateSetting('previewMode', true);
    console.log('ðŸŽ¨ Preview mode enabled');
  };

  const disablePreview = () => {
    updateSetting('previewMode', false);
    console.log('ðŸŽ¨ Preview mode disabled');
  };


  // Check if minimum setup is complete
  const isMinimumSetupComplete = () => {
    return settings.enabled && 
           settings.companyName && 
           settings.primaryColor;
  };

  // Load settings from backend on mount
  useEffect(() => {
    const loadSettings = async () => {
      const savedAgencyId = localStorage.getItem('whiteLabel-agencyId');
      if (savedAgencyId) {
        try {
          setIsLoading(true);
          const backendSettings = await whitelabelAPI.getWhitelabelSettings(savedAgencyId);
          setSettings(prev => ({ ...prev, ...backendSettings }));
          console.log('âœ… Loaded settings from backend');
        } catch (error) {
          console.warn('Could not load backend settings, using localStorage:', error);
        } finally {
          setIsLoading(false);
        }
      }
    };

    loadSettings();
  }, []);

  const value = {
    // Settings state
    settings,
    isLoading,
    error,
    agencyId,
    setAgencyId,

    // Settings actions
    updateSetting,
    updateSettings,
    resetSettings,
    saveSettings,

    // File uploads
    handleLogoUpload,
    handleFaviconUpload,
    handleReportLogoUpload,
    uploadFile,

    // Preview mode
    togglePreviewMode,
    enablePreview,
    disablePreview,

    // Setup wizard
    nextStep,
    prevStep,
    completeSetup,

    // Validation
    validateDomain,
    isMinimumSetupComplete,

    // Computed values
    effectiveBranding,
    getEffectiveBranding,

    // Constants
    DEFAULT_SETTINGS
  };

  return (
    <WhiteLabelContext.Provider value={value}>
      {children}
    </WhiteLabelContext.Provider>
  );
};